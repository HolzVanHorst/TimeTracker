ğŸ“‹ TimeTracker - Komplette Dokumentation
ğŸ—ï¸ Code-Konventionen & Best Practices
1. Type Hints
Alle Funktionen haben Type Hints: def load_config(self) -> Optional[dict]:

Return-Types angeben: bool, dict, None, List[str]

Parameter-Types: config: dict, app_path: str

2. Docstrings (Google Style)
python
def load_config(self) -> Optional[dict]:
    """Lade die config.json Datei.
    
    Returns:
        dict: Konfiguration als Dictionary
        None: Wenn Datei nicht existiert
    """
3. Konstanten (UPPER_CASE)
Alle fixen Werte in config.py

Pfade als Path-Objekte

Default-Werte zentral definiert

4. Private Methoden (_name)
Hilfsmethoden mit Underscore: _validate_config(), _add_app()

Signalisiert: "Nur interne Verwendung"

5. Custom Exceptions
Eigene Exception-Klasse fÃ¼r jeden Error-Typ

Datei: exceptions.py

Base Exception: TimeTrackerError

Spezifische: ConfigError, DatabaseError, TrackerError

6. Logging statt Print
python
logger = setup_logger(__name__)
logger.info("Config geladen")
logger.error("Fehler beim Laden")
logger.warning("Warnung")
logger.debug("Debug-Info")
Logs gehen zu Console UND Datei (data/tracker.log)

Alle kritischen Operationen geloggt

Autostart-Modus: Nur Logs, keine Print-Statements

7. Input Validation
Alle Config-Daten validieren: _validate_config()

User-Input checken: .strip(), nicht leer

Type-Checks durchfÃ¼hren

8. Encoding (UTF-8)
python
with open(file, 'r', encoding='utf-8') as f:
Umlaute funktionieren Ã¼berall

Standard seit Python 3

9. Separation of Concerns
Jede .py Datei hat eine Aufgabe

Config-Logik in config.py

String-Logik in strings.py

UI-Logik in app.py

Tracker-Logik in tracker.py

DB-Logik in database.py

10. Fehlerbehandlung
python
try:
    # Code
except SpecificError as e:
    logger.error(f"Error: {e}")
    raise
except Exception as e:
    logger.error(f"Unexpected: {e}")
11. Zentrale Texte (i18n-Ready)
Alle UI-Texte in strings.py

Class Messages mit Konstanten

Einfach zu Ã¼bersetzen spÃ¤ter

Kein hardcodiertes "Hallo test" im Code

12. Klassen-basiert
python
class TimeTrackerApp:
    def __init__(self):
        self.config_path = CONFIG_PATH
    
    def method(self):
        pass
Alles in Klassen organisiert

State wird in self gespeichert

Keine globalen Variablen

ğŸ“ Projekt-Struktur (Flat Layout)
text
TimeTracker/
â”œâ”€â”€ README.md                      # Dokumentation
â”œâ”€â”€ .gitignore                     # Git-Ignores (data/, __pycache__)
â”œâ”€â”€ .gitattributes                 # Git-Attribute
â”œâ”€â”€ requirements.txt               # Dependencies (pywin32, psutil)
â”œâ”€â”€ main.py                        # Einstiegspunkt (nur 15 Zeilen!)
â”‚
â”œâ”€â”€ timetracker/                   # Python Package
â”‚   â”œâ”€â”€ __init__.py               # Package-Definition
â”‚   â”œâ”€â”€ app.py                    # TimeTrackerApp Klasse (UI/Menu)
â”‚   â”œâ”€â”€ tracker.py                # AppTracker Klasse (Monitoring)
â”‚   â”œâ”€â”€ database.py               # Database Klasse (SQLite)
â”‚   â”œâ”€â”€ config.py                 # Konstanten & Konfiguration
â”‚   â”œâ”€â”€ strings.py                # Alle UI-Texte
â”‚   â”œâ”€â”€ exceptions.py             # Custom Exceptions
â”‚   â””â”€â”€ logger_config.py          # Logging-Setup
â”‚
â””â”€â”€ data/                          # Runtime-Daten (nicht in Git)
    â”œâ”€â”€ config.json               # User-Config (wird erstellt)
    â”œâ”€â”€ tracker.db                # SQLite Database (wird erstellt)
    â””â”€â”€ tracker.log               # Log-Datei (wird erstellt)
Warum Flat-Layout?
Python-Standard (PEP 517)

Nicht zu nested (einfacher als src-layout)

Skalierbar

PyInstaller-friendly

âš™ï¸ Features
1. Initialisierung
text
Menu â†’ "1. Initialisierung"
   â†’ Input: "chrome.exe,vscode.exe,notepad.exe"
   â†’ Erstellt data/config.json
   â†’ Erstellt data/tracker.db
2. Multi-App Tracking
Beliebig viele Apps gleichzeitig tracken

Komma-getrennte Eingabe beim Setup

Jede App einzeln geloggt in DB

Separate Statistiken pro App

3. Monitoring
text
Menu â†’ "1. Tracking starten"
   â†’ LÃ¤uft im Hintergrund
   â†’ PrÃ¼ft aktive Fenster alle 500ms
   â†’ Loggt Start/Stop in SQLite
   â†’ CTRL+C zum Beenden
4. Statistiken (Pro App)
text
Menu â†’ "2. Statistiken"
   â†’ HEUTE:
      â€¢ Ã–ffnungen: Xmal
      â€¢ Gesamtzeit: Xh XXm
      â€¢ Ã˜ pro Ã–ffnung: XXm
   
   â†’ GESAMT:
      â€¢ Ã–ffnungen: Xmal
      â€¢ Gesamtzeit: Xh XXm
      â€¢ Erste Nutzung: TT.MM.JJJJ
5. Settings (App-Management)
text
Menu â†’ "3. Settings"
   â†’ Zeigt aktuelle Apps
   â†’ "1. App hinzufÃ¼gen"    (komma-getrennt)
   â†’ "2. App entfernen"     (einzeln)
   â†’ "3. Apps anzeigen"
   â†’ "4. ZurÃ¼ck"
6. Autostart-Integration
text
TimeTracker.exe                    # Manual: Menu
TimeTracker.exe --autostart        # Autostart: Still tracking
Erkennung via --autostart Parameter

In Registry: HKEY_CURRENT_USER\...\Run

Keine Console-Ausgabe im Autostart-Mode

Nur Logging in Datei

7. Datenbank (SQLite)
sql
CREATE TABLE app_sessions (
    id INTEGER PRIMARY KEY,
    app_name TEXT,
    app_path TEXT,
    start_time DATETIME,
    end_time DATETIME,
    duration_seconds INTEGER,
    date DATE
)
Jede Session einzeln geloggt

Aggregations-Queries fÃ¼r Stats

Keine Duplikate

8. Logging
Console-Output (INFO Level)

File-Output (data/tracker.log)

Format: [TIMESTAMP] - [MODULE] - [LEVEL] - [MESSAGE]

File-Logging fÃ¼r Autostart-Debugging

ğŸ¯ Klassen-Ãœbersicht
1. TimeTrackerApp (app.py)
Verantwortung: UI, Menu, Benutzerinteraktion

cmd_initialize() - Erste Konfiguration

cmd_run() - Starte Monitoring

cmd_stats() - Zeige Statistiken

cmd_settings() - App-Management

load_config() - Lade Config

save_config() - Speichere Config

show_menu() - Interaktives Menu

2. AppTracker (tracker.py)
Verantwortung: Fenster-Monitoring, AktivitÃ¤ts-Logging

start_monitoring() - Hauptschleife

get_active_window_process() - Aktives Fenster erkennen

is_target_app() - PrÃ¼fe ob App in Liste

log_session() - Speichere Session

3. Database (database.py)
Verantwortung: SQLite-Operationen

init_db() - Erstelle Tabelle

log_session() - INSERT in DB

get_stats_today() - SELECT fÃ¼r heute

get_stats_all_time() - SELECT gesamt

4. Messages (strings.py)
Verantwortung: Alle UI-Texte

Konstanten fÃ¼r alle Ausgaben

Kein hardcoded "print("hallo")"

SpÃ¤ter einfach zu Ã¼bersetzen

5. Config (config.py)
Verantwortung: Zentrale Konstanten

CONFIG_PATH, DB_PATH, LOG_PATH

DEFAULT_CONFIG

Validierungs-Constraints

6. Exceptions (exceptions.py)
Verantwortung: Custom Error-Types

TimeTrackerError (Base)

ConfigError (Config-Probleme)

DatabaseError (DB-Probleme)

TrackerError (Monitoring-Probleme)

7. Logger Config (logger_config.py)
Verantwortung: Logging-Setup

setup_logger() - Erstelle Logger

Console + File Handler

Consistent Format

ğŸ“Š Daten-Flow
text
FIRST RUN:
User
  â†“
main.py
  â†“
TimeTrackerApp.show_menu()
  â†“
cmd_initialize()
  â†“
Input: "chrome.exe,vscode.exe"
  â†“
save_config() â†’ data/config.json
  â†“
Database.init_db() â†’ data/tracker.db
text
TRACKING RUN:
User: "1. Tracking starten"
  â†“
load_config() â† data/config.json
  â†“
AppTracker.start_monitoring()
  â†“
While-Loop: PrÃ¼fe aktives Fenster
  â†“
Wenn App in Liste â†’ log_session()
  â†“
Database.insert() â†’ data/tracker.db
text
STATS RUN:
User: "2. Statistiken"
  â†“
load_config()
  â†“
FÃ¼r jede App:
  â†“
Database.get_stats_today()
  â†“
Database.get_stats_all_time()
  â†“
Formatiere & Print
ğŸ” Sicherheit & Robustheit
Aspekt	Implementierung
Input Validation	_validate_config() prÃ¼ft alle Keys
Type Safety	Type Hints Ã¼berall
Error Handling	Try/Except mit spezifischen Exceptions
Logging	Alle Fehler geloggt
File Operations	UTF-8 Encoding, Exception-handling
Path Security	Path-Objekte (plattformunabhÃ¤ngig)
Config Validation	Liste nicht leer, nur Strings
ğŸ“ Verwendung
Erste Nutzung:
bash
python main.py
â†’ 1 (Initialisierung)
â†’ chrome.exe,vscode.exe,notepad.exe
â†’ âœ… Config erstellt
Tracking starten:
bash
python main.py
â†’ 1 (Tracking starten)
â†’ LÃ¤uft still im Hintergrund
â†’ CTRL+C zum Beenden
Statistiken ansehen:
bash
python main.py
â†’ 2 (Statistiken)
â†’ Zeigt alle Apps mit heute + gesamt
Apps verwalten:
bash
python main.py
â†’ 3 (Settings)
â†’ 1 (App hinzufÃ¼gen) oder 2 (entfernen)
Autostart einrichten:
text
Registry: HKEY_CURRENT_USER\...\Run
Value: C:\Pfad\TimeTracker.exe --autostart
ğŸš€ NÃ¤chste Optionale Features
Feature	Aufwand	Nutzen
Auto-Autostart via Settings	Niedrig	Komfort
CSV-Export fÃ¼r Excel	Niedrig	Analyse
Wochenstatistiken	Niedrig	Ãœbersicht
GUI mit PySimpleGUI	Mittel	Benutzerfreundlichkeit
Echtzeit-Dashboard	Hoch	Monitoring
Mehrsprachigkeit (i18n)	Mittel	Internationalisierung
PyInstaller â†’ .exe	Niedrig	Distribution
âœ… Checkliste Implementiert
 Klassenbasiert (nicht funktional)

 Type Hints Ã¼berall

 Google-Style Docstrings

 Constants (UPPER_CASE)

 Custom Exceptions

 Logging (Console + File)

 Zentrale Strings (i18n-ready)

 Input Validation

 UTF-8 Encoding

 Separation of Concerns

 Fehlerbehandlung

 Multi-App Support

 Autostart-Erkennung (--autostart Parameter)

 Settings/App-Management

 Statistiken (heute + gesamt)

 SQLite Database

 Flat-Layout (Python Standard)

 Nur in main.py (clean entry point)

Das ist deine production-ready Basis! ğŸš€
